/* 
 * Copyright (C) 2006 aeolusc <soarchin@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pspkernel.h>
#include <psptypes.h>
#include <pspdisplay.h>
#include <pspsysmem_kernel.h>
#include <pspgu.h>
#include "font.h"
#include "lang_zh_euc.h"
#include "conf.h"
#include "blend.h"
#include "rgb_color.h"
#include "allocmem.h"


void (*font_line)(int x1, int y1, int x2, int y2);
int (*font_outputn)(int sx, int sy, const char *msg, int count);
void (*font_fillrect)(int x1, int y1, int x2, int y2);

t_bgctx bgctx __attribute__(   (  aligned( 4 ), section( ".bss" )  )   );

int font_output(int x, int y, const char *msg)
{
	return font_outputn(x, y, msg, 0x7FFF0000);
}

#ifdef ENGLISH_UI
#define BUFFER_HZCOUNT	(50)
#else
#define BUFFER_HZCOUNT	(450)
#endif
#define BUFFER_HZDATALEN (BUFFER_HZCOUNT*(sizeof(hzfont)))

static u32 buffer_hzset = 0;
static hzfont hzbuffer[BUFFER_HZCOUNT] __attribute__(   (  aligned( 4 ), section( ".bss" )  )   );

static u8 * _get_hzfont(u16 offset)
{
	int i;
	
	for(i=0;i<BUFFER_HZCOUNT;i++){
		if(hzbuffer[i].offset==offset) return hzbuffer[i].dat;
	}
	
		u8 *hzinfo;
		int fd = sceIoOpen(FONT_DIR, PSP_O_RDONLY, 0777);
		if(fd < 0)		return hzbuffer[0].dat;
		
		hzbuffer[buffer_hzset].offset = offset;		
		sceIoLseek(fd,2048+offset*18,0);
		sceIoRead(fd,hzbuffer[buffer_hzset].dat,18);
		sceIoClose(fd);
		hzinfo = hzbuffer[buffer_hzset].dat;
		
		buffer_hzset++;
		if(buffer_hzset>=BUFFER_HZCOUNT) buffer_hzset=BUFFER_HZCOUNT/10;		//最先进入缓存的1/10字认为常用字,不更新
		
		return hzinfo;
}

int IsHzcode(int x, const char *msg)
{
	return (((((unsigned char)msg[x] > 0xA0 && (unsigned char)msg[x] < 0xA9) || ((unsigned char)msg[x] > 0xAC && (unsigned char)msg[x] < 0xFD)) && (unsigned char)msg[x + 1] > 0xA0)
		);
}

static u8 * GetHz(int x, const char *msg)
{
//http://charset.uic.jp/show/cp51932/
#define CODESKIP 846-96 //惰茶山 16*6*(?) 0xAD
#define CODESKIP2 846 //惰茶山 16*6*(?) 0xB0
#define CODESKIP3 846+6624 //惰茶山 16*6*(?) 0xB0-0xF4のスキップ
#define NEXTCODE 94 //惰茶山 16*6

			if((unsigned char)msg[x] > 0xA0 && (unsigned char)msg[x] < 0xA9 && (unsigned char)msg[x + 1] > 0xA0)
				return _get_hzfont( (int)((unsigned char)msg[x] - 0xA1) * NEXTCODE + (int)((unsigned char)msg[x + 1] - 0xA1) );
			else if((unsigned char)msg[x] == 0xAD &&  (unsigned char)msg[x + 1] > 0xA0)
				return _get_hzfont(CODESKIP  + (int)((unsigned char)msg[x + 1] - 0xA1) );

			else if((unsigned char)msg[x] > 0xAF && (unsigned char)msg[x] < 0xF5  && (unsigned char)msg[x + 1] > 0xA0)
				return _get_hzfont( CODESKIP2 + (int)((unsigned char)msg[x] - 0xB0) * NEXTCODE + (int)((unsigned char)msg[x + 1] - 0xA1) );
			else if((unsigned char)msg[x] > 0xF8 && (unsigned char)msg[x] < 0xFD  && (unsigned char)msg[x + 1] > 0xA0)
				return _get_hzfont( CODESKIP3 + (int)((unsigned char)msg[x] - 0xF9) * NEXTCODE + (int)((unsigned char)msg[x + 1] - 0xA1) );
}


u8 efont[]__attribute__(   (  aligned( 1 ), section( ".data" )  )   ) =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0xA5, 0x81, 0xA5, 0x99, 0x42, 0x3C, 
	0x3C, 0x7E, 0xDB, 0xFF, 0xFF, 0xDB, 0x66, 0x3C, 0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, 
	0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x10, 0x38, 0x54, 0xFE, 0x54, 0x10, 0x38, 0x00, 
	0x10, 0x38, 0x7C, 0xFE, 0xFE, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 
	0xFF, 0xFF, 0xFF, 0xE7, 0xE7, 0xFF, 0xFF, 0xFF, 0x38, 0x44, 0x82, 0x82, 0x82, 0x44, 0x38, 0x00, 
	0xC7, 0xBB, 0x7D, 0x7D, 0x7D, 0xBB, 0xC7, 0xFF, 0x0F, 0x03, 0x05, 0x79, 0x88, 0x88, 0x88, 0x70, 
	0x38, 0x44, 0x44, 0x44, 0x38, 0x10, 0x7C, 0x10, 0x30, 0x28, 0x24, 0x24, 0x28, 0x20, 0xE0, 0xC0, 
	0x3C, 0x24, 0x3C, 0x24, 0x24, 0xE4, 0xDC, 0x18, 0x10, 0x54, 0x38, 0xEE, 0x38, 0x54, 0x10, 0x00, 
	0x10, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x10, 0x10, 0x10, 
	0x10, 0x10, 0x10, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x10, 0x10, 0x10, 
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0xF0, 0x10, 0x10, 0x10, 0x10, 
	0x10, 0x10, 0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0xF0, 0x00, 0x00, 0x00, 0x00, 
	0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 
	0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x10, 0x10, 0xFF, 0x10, 0x10, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x20, 0x00, 
	0x50, 0x50, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x50, 0xF8, 0x50, 0xF8, 0x50, 0x50, 0x00, 
	0x20, 0x78, 0xA0, 0x70, 0x28, 0xF0, 0x20, 0x00, 0xC0, 0xC8, 0x10, 0x20, 0x40, 0x98, 0x18, 0x00, 
	0x40, 0xA0, 0x40, 0xA8, 0x90, 0x98, 0x60, 0x00, 0x10, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x10, 0x20, 0x40, 0x40, 0x40, 0x20, 0x10, 0x00, 0x40, 0x20, 0x10, 0x10, 0x10, 0x20, 0x40, 0x00, 
	0x20, 0xA8, 0x70, 0x20, 0x70, 0xA8, 0x20, 0x00, 0x00, 0x20, 0x20, 0xF8, 0x20, 0x20, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x40, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 
	0x70, 0x88, 0x98, 0xA8, 0xC8, 0x88, 0x70, 0x00, 0x20, 0x60, 0xA0, 0x20, 0x20, 0x20, 0xF8, 0x00, 
	0x70, 0x88, 0x08, 0x10, 0x60, 0x80, 0xF8, 0x00, 0x70, 0x88, 0x08, 0x30, 0x08, 0x88, 0x70, 0x00, 
	0x10, 0x30, 0x50, 0x90, 0xF8, 0x10, 0x10, 0x00, 0xF8, 0x80, 0xE0, 0x10, 0x08, 0x10, 0xE0, 0x00, 
	0x30, 0x40, 0x80, 0xF0, 0x88, 0x88, 0x70, 0x00, 0xF8, 0x88, 0x10, 0x20, 0x20, 0x20, 0x20, 0x00, 
	0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00, 0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00, 
	0x00, 0x00, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x20, 0x20, 0x40, 
	0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00, 0x00, 0x00, 0xF8, 0x00, 0xF8, 0x00, 0x00, 0x00, 
	0xC0, 0x60, 0x30, 0x18, 0x30, 0x60, 0xC0, 0x00, 0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00, 
	0x70, 0x88, 0x08, 0x68, 0xA8, 0xA8, 0x70, 0x00, 0x20, 0x50, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x00, 
	0xF0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xF0, 0x00, 0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00, 
	0xE0, 0x50, 0x48, 0x48, 0x48, 0x50, 0xE0, 0x00, 0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0xF8, 0x00, 
	0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0x80, 0x00, 0x70, 0x88, 0x80, 0xB8, 0x88, 0x88, 0x70, 0x00, 
	0x88, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x88, 0x00, 0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00, 
	0x38, 0x10, 0x10, 0x10, 0x90, 0x90, 0x60, 0x00, 0x88, 0x90, 0xA0, 0xC0, 0xA0, 0x90, 0x88, 0x00, 
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xF8, 0x00, 0x88, 0xD8, 0xA8, 0xA8, 0x88, 0x88, 0x88, 0x00, 
	0x88, 0xC8, 0xC8, 0xA8, 0x98, 0x98, 0x88, 0x00, 0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 
	0xF0, 0x88, 0x88, 0xF0, 0x80, 0x80, 0x80, 0x00, 0x70, 0x88, 0x88, 0x88, 0xA8, 0x90, 0x68, 0x00, 
	0xF0, 0x88, 0x88, 0xF0, 0xA0, 0x90, 0x88, 0x00, 0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00, 
	0xF8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 
	0x88, 0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x00, 0x88, 0x88, 0x88, 0xA8, 0xA8, 0xD8, 0x88, 0x00, 
	0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00, 0x88, 0x88, 0x88, 0x70, 0x20, 0x20, 0x20, 0x00, 
	0xF8, 0x08, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00, 0x70, 0x40, 0x40, 0x40, 0x40, 0x40, 0x70, 0x00, 
	0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00, 
	0x20, 0x50, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 
	0x40, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00, 
	0x80, 0x80, 0xB0, 0xC8, 0x88, 0xC8, 0xB0, 0x00, 0x00, 0x00, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00, 
	0x08, 0x08, 0x68, 0x98, 0x88, 0x98, 0x68, 0x00, 0x00, 0x00, 0x70, 0x88, 0xF8, 0x80, 0x70, 0x00, 
	0x10, 0x28, 0x20, 0xF8, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x68, 0x98, 0x98, 0x68, 0x08, 0x70, 
	0x80, 0x80, 0xF0, 0x88, 0x88, 0x88, 0x88, 0x00, 0x20, 0x00, 0x60, 0x20, 0x20, 0x20, 0x70, 0x00, 
	0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x90, 0x60, 0x40, 0x40, 0x48, 0x50, 0x60, 0x50, 0x48, 0x00, 
	0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00, 0x00, 0x00, 0xD0, 0xA8, 0xA8, 0xA8, 0xA8, 0x00, 
	0x00, 0x00, 0xB0, 0xC8, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00, 
	0x00, 0x00, 0xB0, 0xC8, 0xC8, 0xB0, 0x80, 0x80, 0x00, 0x00, 0x68, 0x98, 0x98, 0x68, 0x08, 0x08, 
	0x00, 0x00, 0xB0, 0xC8, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x78, 0x80, 0xF0, 0x08, 0xF0, 0x00, 
	0x40, 0x40, 0xF0, 0x40, 0x40, 0x48, 0x30, 0x00, 0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00, 
	0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00, 0x00, 0x00, 0x88, 0xA8, 0xA8, 0xA8, 0x50, 0x00, 
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00, 0x00, 0x00, 0x88, 0x88, 0x98, 0x68, 0x08, 0x70, 
	0x00, 0x00, 0xF8, 0x10, 0x20, 0x40, 0xF8, 0x00, 0x18, 0x20, 0x20, 0x40, 0x20, 0x20, 0x18, 0x00, 
	0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x00, 0xC0, 0x20, 0x20, 0x10, 0x20, 0x20, 0xC0, 0x00, 
	0x40, 0xA8, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0xF8, 0x00, 0x00, 0x00
};

static u32 (*rgb2color)(u32 r, u32 g, u32 b);

void color_init()
{
	bgctx.bg_r=(config.bg_color>>16)&0xff,bgctx.bg_g=(config.bg_color>>8)&0xff,bgctx.bg_b=config.bg_color&0xff;
	bgctx.bg_a=(config.bg_color>>24);
	if(bgctx.bg_a==0) bgctx.bg_a=0xb0;
	
	u32 font_r=(config.font_color>>16)&0xff,font_g=(config.font_color>>8)&0xff,font_b=config.font_color&0xff;
	
	bgctx.rgb = rgb2color(bgctx.bg_r,bgctx.bg_g,bgctx.bg_b);
	bgctx.font_rgb = rgb2color(font_r,font_g,font_b);
}


static int font_output_32bit(int sx, int sy, const char *msg, int count)
{
	unsigned int * vram32 = (unsigned int *)bgctx.vram;

	int p, x, y, ox = sx;
#ifdef ENABLE_CLANG
	u8 * hz;
#endif
	for(x = 0; x < count && msg[x]; x++)
	{
#ifdef ENABLE_CLANG
		if(IsHzcode(x,msg))
		{
			hz = GetHz(x,msg);
			for(y = 0; y < 12; y ++)
			{
				int offset = (sy + y - 2) * bgctx.bufferwidth + ox;
				u8 pmap = *hz ++;
				for(p = 0; p < 8; p ++)
				{
					if(pmap & 0x80)
						vram32[offset] = bgctx.font_rgb;
					pmap <<= 1;
					offset ++;
				}
				pmap = *hz ++;
				for(p = 0; p < 4; p ++)
				{
					if(pmap & 0x80)
						vram32[offset] = bgctx.font_rgb;
					pmap <<= 1;
					offset ++;
				}
				y ++;
				offset = (sy + y - 2) * bgctx.bufferwidth + ox;
				for(p = 0; p < 4; p ++)
				{
					if(pmap & 0x80)
						vram32[offset] = bgctx.font_rgb;
					pmap <<= 1;
					offset ++;
				}
				pmap = *hz ++;
				for(p = 0; p < 8; p ++)
				{
					if(pmap & 0x80)
						vram32[offset] = bgctx.font_rgb;
					pmap <<= 1;
					offset ++;
				}
			}
			ox += 12;
			x ++;
		}
		else
		{
#endif

		u8 code = msg[x] & 0xff;


#ifdef EXTEND_UINX_CODE
		if(code == 0x8E){
			code= msg[x+1] & 0xff;
		x++;
		}
#endif

		for(y = 0; y < 8; y ++)
		{
			int offset = (sy + y) * bgctx.bufferwidth + ox;
			u8 pmap = efont[code * 8 + y];
			for(p = 0; p < 6; p ++)
			{
				if(pmap & 0x80)
					vram32[offset] = bgctx.font_rgb;
				pmap <<= 1;
				offset ++;
			}
		}
		ox += 6;
#ifdef ENABLE_CLANG
		}
#endif
	}
	return x;
}

static int font_output_16bit(int sx, int sy, const char *msg, int count)
{
	unsigned short * vram16 = (unsigned short *)bgctx.vram;

	int p, x, y, ox = sx;
#ifdef ENABLE_CLANG
	u8 * hz;
#endif
	for(x = 0; x < count && msg[x]; x++)
	{
#ifdef ENABLE_CLANG
		if(IsHzcode(x,msg))
		{
			hz = GetHz(x,msg);
			for(y = 0; y < 12; y ++)
			{
				int offset = (sy + y - 2) * bgctx.bufferwidth + ox;
				u8 pmap = *hz ++;
				for(p = 0; p < 8; p ++)
				{
					if(pmap & 0x80)
						vram16[offset] = bgctx.font_rgb;
					pmap <<= 1;
					offset ++;
				}
				pmap = *hz ++;
				for(p = 0; p < 4; p ++)
				{
					if(pmap & 0x80)
						vram16[offset] = bgctx.font_rgb;
					pmap <<= 1;
					offset ++;
				}
				y ++;
				offset = (sy + y - 2) * bgctx.bufferwidth + ox;
				for(p = 0; p < 4; p ++)
				{
					if(pmap & 0x80)
						vram16[offset] = bgctx.font_rgb;
					pmap <<= 1;
					offset ++;
				}
				pmap = *hz ++;
				for(p = 0; p < 8; p ++)
				{
					if(pmap & 0x80)
						vram16[offset] = bgctx.font_rgb;
					pmap <<= 1;
					offset ++;
				}
			}
			ox += 12;
			x ++;
		}
		else
		{
#endif
		u8 code = msg[x] & 0xff;

#ifdef EXTEND_UINX_CODE
		if(code == 0x8E){
			code= msg[x+1] & 0xff;
		x++;
		}
#endif
		for(y = 0; y < 8; y ++)
		{
			int offset = (sy + y) * bgctx.bufferwidth + ox;
			u8 pmap = efont[code * 8 + y];
			for(p = 0; p < 6; p ++)
			{
				if(pmap & 0x80)
					vram16[offset] = bgctx.font_rgb;
				pmap <<= 1;
				offset ++;
			}
		}
		ox += 6;
#ifdef ENABLE_CLANG
		}
#endif
	}
	return x;
}

static void font_fillrect_32bit(int x1, int y1, int x2, int y2)
{
	unsigned int * vram32 = (unsigned int *)bgctx.vram;
	unsigned int * bufvram32 = (unsigned int *)BGbuf_get();
	int x, y;

	for(y = y1; y <= y2; y ++)
	{
		int offset = y * bgctx.bufferwidth + x1;
		int tmp = (y - BACKUP_Y1) * (BACKUP_X2-BACKUP_X1) - BACKUP_X1;
		for(x = x1; x <= x2; x ++)
		{
			if(x<BACKUP_X1 || x>=BACKUP_X2 || y<BACKUP_Y1 || y>=BACKUP_Y2 || bufvram32==NULL)
				vram32[offset] = bgctx.rgb;
			else vram32[offset] = bufvram32[x+tmp];
			offset ++;
		}
	}
}

static void font_fillrect_16bit(int x1, int y1, int x2, int y2)
{
	unsigned short * vram16 = (unsigned short *)bgctx.vram;
	unsigned short * bufvram16 = (unsigned short *)BGbuf_get();	
	int x, y;
	for(y = y1; y <= y2; y ++)
	{
		int offset = y * bgctx.bufferwidth + x1;
		int tmp = (y - BACKUP_Y1) * (BACKUP_X2-BACKUP_X1) - BACKUP_X1;
		for(x = x1; x <= x2; x ++)
		{
			if(x<BACKUP_X1 || x>=BACKUP_X2 || y<BACKUP_Y1 || y>=BACKUP_Y2 || bufvram16==NULL)
				vram16[offset] = bgctx.rgb;
			else vram16[offset] = bufvram16[x+tmp];
			offset ++;
		}
	}
}

static void font_line_32bit(int x1, int y1, int x2, int y2)
{
	unsigned int * vram32 = (unsigned int *)bgctx.vram;
	int dx = x2 - x1, dy = y2 - y1;
	if(dx < 0)
		dx = -dx;
	if(dy < 0)
		dy = -dy;
	int d = -dx, x = x1, y = y1;
	if(dx >= dy)
	{
		if(y2 < y1)
		{
			int t = x1; x1 = x2; x2 = t; t = y1; y1 = y2; y2 = t;
		}
		vram32 += y1 * bgctx.bufferwidth + x1;
		if(x1 < x2)
		{
			for(x = x1; x <= x2; x ++)
			{
				if(d > 0)
				{
					y ++;
					vram32 += 512;
					d -= 2 * dx;
				}
				d += 2 * dy;
				* vram32 = bgctx.font_rgb;
				vram32 ++;
			}
		}
		else
		{
			for(x = x1; x >= x2; x --)
			{
				if(d > 0)
				{
					y ++;
					vram32 += 512;
					d -= 2 * dx;
				}
				d += 2 * dy;
				* vram32 = bgctx.font_rgb;
				vram32 --;
			}
		}
	}
	else
	{
		if(x2 < x1)
		{
			int t = x1; x1 = x2; x2 = t; t = y1; y1 = y2; y2 = t;
		}
		vram32 += y1 * bgctx.bufferwidth + x1;
		if(y1 < y2)
		{
			for(y = y1; y <= y2; y ++)
			{
				if(d > 0)
				{
					x ++;
					vram32 ++;
					d -= 2 * dy;
				}
				d += 2 * dx;
				* vram32 = bgctx.font_rgb;
				vram32 += 512;
			}
		}
		else
		{
			for(y = y1; y >= y2; y --)
			{
				if(d > 0)
				{
					x ++;
					vram32 ++;
					d -= 2 * dy;
				}
				d += 2 * dx;
				* vram32 = bgctx.font_rgb;
				vram32 -= 512;
			}
		}
	}
}

static void font_line_16bit(int x1, int y1, int x2, int y2)
{
	unsigned short * vram16 = (unsigned short *)bgctx.vram;
	int dx = x2 - x1, dy = y2 - y1;
	if(dx < 0)
		dx = -dx;
	if(dy < 0)
		dy = -dy;
	int d = -dx, x = x1, y = y1;
	if(dx >= dy)
	{
		if(y2 < y1)
		{
			int t = x1; x1 = x2; x2 = t; t = y1; y1 = y2; y2 = t;
		}
		vram16 += y1 * bgctx.bufferwidth + x1;
		if(x1 < x2)
		{
			for(x = x1; x <= x2; x ++)
			{
				if(d > 0)
				{
					y ++;
					vram16 += 512;
					d -= 2 * dx;
				}
				d += 2 * dy;
				* vram16 = bgctx.font_rgb;
				vram16 ++;
			}
		}
		else
		{
			for(x = x1; x >= x2; x --)
			{
				if(d > 0)
				{
					y ++;
					vram16 += 512;
					d -= 2 * dx;
				}
				d += 2 * dy;
				* vram16 = bgctx.font_rgb;
				vram16 --;
			}
		}
	}
	else
	{
		if(x2 < x1)
		{
			int t = x1; x1 = x2; x2 = t; t = y1; y1 = y2; y2 = t;
		}
		vram16 += y1 * bgctx.bufferwidth + x1;
		if(y1 < y2)
		{
			for(y = y1; y <= y2; y ++)
			{
				if(d > 0)
				{
					x ++;
					vram16 ++;
					d -= 2 * dy;
				}
				d += 2 * dx;
				* vram16 = bgctx.font_rgb;
				vram16 += 512;
			}
		}
		else
		{
			for(y = y1; y >= y2; y --)
			{
				if(d > 0)
				{
					x ++;
					vram16 ++;
					d -= 2 * dy;
				}
				d += 2 * dx;
				* vram16 = bgctx.font_rgb;
				vram16 -= 512;
			}
		}
	}
}
/* 
static void* g_vram1;
static void* g_vram2;
static void* g_base;
 */
typedef struct _vram_ptr{
	void* g_vram1;
	void* g_vram2;
	void* g_base;
}t_vram_gv;

static t_vram_gv vram_gv __attribute__(   (  aligned( 4 ), section( ".bss" )  )   );

extern void font_get_vram()		//获取framebuffer adr,很黄很暴力
{
	int i,unk;
	i=0;			//某些没双缓冲的
	sceDisplayGetFrameBuf(&vram_gv.g_vram1, &bgctx.bufferwidth, &bgctx.pixelformat, &unk);
	do{
		sceDisplayWaitVblankStart();
		sceDisplayGetFrameBuf(&vram_gv.g_vram2, &bgctx.bufferwidth, &bgctx.pixelformat, &unk);
		i++;
	}while((vram_gv.g_vram1==vram_gv.g_vram2) && i<20);
	vram_gv.g_vram1 = (void *)(((unsigned long)vram_gv.g_vram1) | 0x40000000);
	vram_gv.g_vram2 = (void *)(((unsigned long)vram_gv.g_vram2) | 0x40000000);	
}

extern int font_init()
{
	int pwidth, pheight, unk;
	sceDisplayGetMode(&unk, &pwidth, &pheight);
	sceDisplayGetFrameBuf(&vram_gv.g_base, &bgctx.bufferwidth, &bgctx.pixelformat, unk);
	if(bgctx.bufferwidth == 0)		return -1;
	vram_gv.g_base = (void *)(((unsigned long)vram_gv.g_base) | 0x40000000);
	bgctx.vram = vram_gv.g_base;
	
	switch(bgctx.pixelformat)
	{
	case PSP_DISPLAY_PIXEL_FORMAT_565:
		rgb2color = rgb2color565;
		font_outputn = font_output_16bit;
		font_fillrect = font_fillrect_16bit;
		font_line = font_line_16bit;
		break;
	case PSP_DISPLAY_PIXEL_FORMAT_5551:
		rgb2color = rgb2color5551;
		font_outputn = font_output_16bit;
		font_fillrect = font_fillrect_16bit;
		font_line = font_line_16bit;
		break;
	case PSP_DISPLAY_PIXEL_FORMAT_4444:
		rgb2color = rgb2color4444;
		font_outputn = font_output_16bit;
		font_fillrect = font_fillrect_16bit;
		font_line = font_line_16bit;
		break;
	case PSP_DISPLAY_PIXEL_FORMAT_8888:
		rgb2color = rgb2color8888;
		font_outputn = font_output_32bit;
		font_fillrect = font_fillrect_32bit;
		font_line = font_line_32bit;
		break;
	default:
		return -1;
	}
	
	color_init();
	initBG();

	return 0;
}

void font_switch_vram()
{
 	if (bgctx.vram == vram_gv.g_vram1) bgctx.vram = vram_gv.g_vram2;
	else bgctx.vram = vram_gv.g_vram1;
}

extern void font_switch_refresh()
{
	sceDisplayWaitVblankStart();
	sceDisplaySetFrameBuf((void *)((unsigned long)bgctx.vram & ~0x40000000), bgctx.bufferwidth, bgctx.pixelformat, 0);
	font_switch_vram();
}

extern void font_switch_back()
{
	bgctx.vram = vram_gv.g_base;
	font_refresh();
}

extern void font_refresh()
{
	sceDisplayWaitVblankStart();
	sceDisplaySetFrameBuf((void *)((unsigned long)bgctx.vram & ~0x40000000), bgctx.bufferwidth, bgctx.pixelformat, 0);
}


